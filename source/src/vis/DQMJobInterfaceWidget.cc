/// \file DQMJobInterfaceWidget.cc
/*
 *
 * DQMJobInterfaceWidget.cc source template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 24 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/vis/DQMJobInterfaceWidget.h"
#include "dqm4hep/vis/DQMJobInterface.h"
#include "DQMVizConfig.h"

// -- qt headers
#include <QMenu>
#include <QMenuBar>
#include <QAction>
#include <QWidget>
#include <QApplication>
#include <QSplitter>
#include <QMessageBox>
#include <QFileDialog>
#include <QTextEdit>
#include <QTextStream>
#include <QDebug>
#include <QInputDialog>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFormLayout>
#include <QGroupBox>
#include <QHeaderView>
#include <QContextMenuEvent>

// -- libssh headers
#include <libssh/libssh.h>
#include <libssh/sftp.h>
// #include <sys/stat.h>
#include <fcntl.h>

namespace dqm4hep
{

DQMJobInterfaceWidget::DQMJobInterfaceWidget(QWidget *pParent):
    QWidget(pParent),
    m_pAutomaticModeButton(0)
{
    m_pJobIterface = new DQMJobInterface();

    QLayout *pMainLayout = new QVBoxLayout();
    setLayout(pMainLayout);

    QHBoxLayout *pComboBoxLayout = new QHBoxLayout();

    QGroupBox *pComboBoxGroupBox = new QGroupBox();
    pMainLayout->addWidget(pComboBoxGroupBox);

    m_pAutomaticModeButton = new QPushButton("Start");
    pComboBoxLayout->addWidget(m_pAutomaticModeButton);

    QLabel *pUpdatePeriodLabel = new QLabel("Update period (secs) : ");
    pComboBoxLayout->addWidget(pUpdatePeriodLabel);

    m_pUpdatePeriodSpinBox = new QSpinBox();
    m_pUpdatePeriodSpinBox->setValue(5);
    pComboBoxLayout->addWidget(m_pUpdatePeriodSpinBox);

    connect(m_pAutomaticModeButton, SIGNAL(clicked()), this, SLOT(handleAutomaticModeButtonClicked()));
    connect(m_pUpdatePeriodSpinBox, SIGNAL(valueChanged(int)), this, SLOT(handleAutomaticModeValueChanged(int)));
    connect(m_pJobIterface, SIGNAL(statusReceived(const QString &)), this, SLOT(updateStatus(const QString &)));

    QSpacerItem *p_HSpacer = new QSpacerItem(1, 0, QSizePolicy::Expanding, QSizePolicy::Minimum);
    pComboBoxLayout->addSpacerItem(p_HSpacer);

    QLabel *pKillComboBoxCaption = new QLabel("Set Kill Method");
    pComboBoxLayout->addWidget(pKillComboBoxCaption);

    m_pKillComboBoxWidget = new QComboBox();
    m_pKillComboBoxWidget->addItem("HUP (Hang Up): 1", 1);
    m_pKillComboBoxWidget->addItem("INT (Interrupt): 2", 2);
    m_pKillComboBoxWidget->addItem("QUIT (Quit): 3", 3);
    m_pKillComboBoxWidget->addItem("ABRT (Abort): 6", 6);
    m_pKillComboBoxWidget->addItem("KILL (Non-ignorable kill): 9", 9);
    m_pKillComboBoxWidget->addItem("ALRM (Alarm Clock): 14", 14);
    m_pKillComboBoxWidget->addItem("TERM (Software Term Signal): 15", 15);
    m_pKillComboBoxWidget->setCurrentIndex(1); // Default: Interrupt = kill -2

    pComboBoxLayout->addWidget(m_pKillComboBoxWidget);
    pComboBoxGroupBox->setLayout(pComboBoxLayout);

    m_pTreeWidget = new QTreeWidget();
    pMainLayout->addWidget(m_pTreeWidget);

    m_pTreeWidget->setColumnCount(4);
    m_pTreeWidget->setHeaderLabels(QStringList() << "Job Control" << "Program Name" << "PID" << "Status");

    // Create Buttons
    QWidget *pButtonWidget = new QWidget();
    pMainLayout->addWidget(pButtonWidget);

    QHBoxLayout *pButtonHLayout = new QHBoxLayout();
    pButtonWidget->setLayout(pButtonHLayout);

    m_pLoadFileButton = new QPushButton("Load file");
    pButtonHLayout->addWidget(m_pLoadFileButton);
    connect(m_pLoadFileButton, SIGNAL(clicked()), this, SLOT(loadJsonFile()));

    m_pReloadFileButton = new QPushButton("Reload file");
    pButtonHLayout->addWidget(m_pReloadFileButton);
    connect(m_pReloadFileButton, SIGNAL(clicked()), this, SLOT(reloadJsonFile()));

    m_pOpenLogFileButton = new QPushButton("Open LogFile");
    pButtonHLayout->addWidget(m_pOpenLogFileButton);
    connect(m_pOpenLogFileButton, SIGNAL(clicked()), this, SLOT(openLogFile()));

    QSpacerItem *p_HButtonSpacer = new QSpacerItem(1, 0, QSizePolicy::Expanding, QSizePolicy::Minimum);
    pButtonHLayout->addSpacerItem(p_HButtonSpacer);

    m_pUpdateButton = new QPushButton("Update");
    pButtonHLayout->addWidget(m_pUpdateButton);
    connect(m_pUpdateButton, SIGNAL(clicked()), this, SLOT(updateJobStatus()));

    // Create Menus / Menus Entries
    createActions();
    createMenus();
}

//-------------------------------------------------------------------------------------------------

DQMJobInterfaceWidget::~DQMJobInterfaceWidget()
{
    delete m_pJobIterface;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMJobInterfaceWidget::getCurrentJsonFile() const
{
    return m_currentJsonFile;
}

//-------------------------------------------------------------------------------------------------

DQMJobInterface *DQMJobInterfaceWidget::getJobInterface() const
{
    return m_pJobIterface;
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::createActions()
{
    m_pLoadFileAction = new QAction("Load File", this);
    connect(m_pLoadFileAction, SIGNAL(triggered()), this, SLOT(loadJsonFile()));

    m_pReloadFileAction = new QAction("Reload File", this);
    connect(m_pReloadFileAction, SIGNAL(triggered()), this, SLOT(reloadJsonFile()));

    m_pOpenLogFileAction = new QAction("Open LogFile", this);
    connect(m_pOpenLogFileAction, SIGNAL(triggered()), this, SLOT(openLogFile()));

    m_pStartHostJobsAction = new QAction("Start host jobs", this);
    connect(m_pStartHostJobsAction, SIGNAL(triggered()), this, SLOT(startHostJobs()));

    m_pClearHostJobsAction = new QAction("Kill host jobs", this);
    connect(m_pClearHostJobsAction, SIGNAL(triggered()), this, SLOT(clearHostJobs()));

    m_pKillJobAction = new QAction("Kill selected job", this);
    connect(m_pKillJobAction, SIGNAL(triggered()), this, SLOT(killSelectedJob()));

    m_pRestartJobAction = new QAction("Restart selected job", this);
    connect(m_pRestartJobAction, SIGNAL(triggered()), this, SLOT(restartSelectedJob()));

    m_pStartJobAction = new QAction("Start selected job", this);
    connect(m_pStartJobAction, SIGNAL(triggered()), this, SLOT(startSelectedJob()));

    m_pClearAllJobsAction = new QAction("Kill all jobs", this);
    connect(m_pClearAllJobsAction, SIGNAL(triggered()), this, SLOT(clearAllJobs()));

    m_pRestartAllJobsAction = new QAction("Restart all jobs", this);
    connect(m_pRestartAllJobsAction, SIGNAL(triggered()), this, SLOT(restartAllJobs()));

    m_pStartAllJobsAction = new QAction("Start all jobs", this);
    connect(m_pStartAllJobsAction, SIGNAL(triggered()), this, SLOT(startAllJobs()));

    m_pUpdateAction = new QAction("Update jobs", this);
    connect(m_pUpdateAction, SIGNAL(triggered()), this, SLOT(updateJobStatus()));
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::createMenus()
{
    m_pMenuBar = new QMenuBar();
    m_pFileMenu = m_pMenuBar->addMenu("&File");
    m_pFileMenu->addAction(m_pLoadFileAction);
    m_pFileMenu->addAction(m_pReloadFileAction);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::contextMenuEvent(QContextMenuEvent *event)
{
    m_pContextMenu = new QMenu();
    m_pContextMenu->addAction(m_pStartHostJobsAction);
    m_pContextMenu->addAction(m_pClearHostJobsAction);

    m_pContextMenu->addSeparator();
    m_pContextMenu->addAction(m_pKillJobAction);
    m_pContextMenu->addAction(m_pRestartJobAction);
    m_pContextMenu->addAction(m_pStartJobAction);

    m_pContextMenu->addSeparator();
    m_pContextMenu->addAction(m_pClearAllJobsAction);
    m_pContextMenu->addAction(m_pRestartAllJobsAction);
    m_pContextMenu->addAction(m_pStartAllJobsAction);

    m_pContextMenu->addSeparator();
    m_pContextMenu->addAction(m_pOpenLogFileAction);
    m_pContextMenu->addAction(m_pUpdateAction);

    m_pStartHostJobsAction->setEnabled(false);
    m_pClearHostJobsAction->setEnabled(false);
    m_pKillJobAction->setEnabled(false);
    m_pRestartJobAction->setEnabled(false);
    m_pStartJobAction->setEnabled(false);
    m_pOpenLogFileAction->setEnabled(false);

    // Activate items as needed
    QTreeWidgetItem* pCurrentItem = m_pTreeWidget->currentItem();

    if (NULL == pCurrentItem)
    {
        m_pContextMenu->exec(event->globalPos());
        return;
    }

    if(pCurrentItem->data(0, Qt::UserRole).value<int>() == HOST_ITEM)
    {
        m_pStartHostJobsAction->setEnabled(true);
        m_pClearHostJobsAction->setEnabled(true);
    }
    else if(pCurrentItem->data(0, Qt::UserRole).value<int>() == JOB_ITEM)
    {
        QString status = pCurrentItem->text(STATUS).at(0);

        if (status.isEmpty())
            return;
        if (pCurrentItem->text(PID).toInt())
            m_pOpenLogFileAction->setEnabled(true);

        if ( status == "D" || status == "X") //Dead
        {
            if (pCurrentItem->text(PID).toInt())
                m_pRestartJobAction->setEnabled(true);
            else
                m_pStartJobAction->setEnabled(true);
        }

        else if ( status != "Z" && // Zombie
                  status != "T"     // Traced or Stopped
                )
        {
            m_pKillJobAction->setEnabled(true);
            m_pRestartJobAction->setEnabled(true);
        }
        else
        {
            m_pStartJobAction->setEnabled(true);
        }
    }

    m_pContextMenu->exec(event->globalPos());
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::loadJsonFile()
{
    QString fileName  = QFileDialog::getOpenFileName(this, "Load file");

    if(fileName.isEmpty())
        return;

    loadJsonFile(fileName.toStdString());
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::loadJsonFile(const std::string &fileName)
{
    if(fileName.empty())
        return;

	if(m_pTreeWidget->topLevelItemCount() != 0)
    {
        QMessageBox::StandardButton button =
            QMessageBox::warning(this, "Load json file",
                                 "WARNING !\n"
                                 "The process table is not empty. Some of the processes are maybe running.\n\n"
                                 "Do you want to kill all running jobs ?",
                                 QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel,
                                 QMessageBox::Cancel);

		switch(button)
        {
        case QMessageBox::Yes:
            this->clearAllJobs();
            break;
        case QMessageBox::No:
            break;
        case QMessageBox::Cancel:
        default:
            return;
        }
    }

    m_pJobIterface->loadJSON(fileName);
    const Json::Value &root(m_pJobIterface->getRoot());
    loadJson(root);

    m_currentJsonFile = fileName;

    updateJobStatus();
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::reloadJsonFile()
{
    if(m_currentJsonFile.empty())
        return;

    loadJsonFile(m_currentJsonFile);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::openLogFile()
{
    QTreeWidgetItem* pSelectedItem = m_pTreeWidget->currentItem();
    if (!pSelectedItem)
        return;

    QString pidStr = pSelectedItem->text(PID);
    QString jobName = pSelectedItem->text(NAME);
    if (pidStr.isEmpty() || jobName.isEmpty())
        return;

    char hostName[1023];
    gethostname(hostName, 1023);
    QString jobHostName = pSelectedItem->parent()->text(NAME);

    QTextEdit *pLogFile = new QTextEdit();
    //TODO Read from jsonFile!
    QString fileName = "/tmp/dimjcPID" + pidStr + ".log";

    QString titleStr = "LogFile " + fileName + " for program '" + jobName + "' on host '" + jobHostName + "'" ;
    pLogFile->setWindowTitle(titleStr);
    pLogFile->resize(700, 700);
    pLogFile->setAttribute(Qt::WA_DeleteOnClose, true);

    // Job is running locally
    if ( hostName == jobHostName )
    {
        QFile file(fileName);
        if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            std::cout << " Error : could not open logFile, you may want to check access rights" << std::endl;
            return;
        }

        QTextStream in(&file);
        QString text;
        text = in.readAll();
        pLogFile->setText(text);
        file.close();
        pLogFile->show();
    }
    // else // Connect to the host through ssh
    {
        std::cout << " Access log through SSH is not yet implemented " << std::endl;
        //TODO implement connection to host with libssh (see libssh API)

         // Testing! Should be properly implemented in a separate class!
        /*
        ssh_session sshSession;
        int verbosity = SSH_LOG_PROTOCOL;
        int port = 22;

        std::cout << " Creating ssh session ... " << std::endl;
        sshSession = ssh_new();
        if (sshSession == NULL)
            exit(-1);
        std::cout << " Creating ssh session ...OK " << std::endl;

        std::cout << " Setting ssh options ... " << std::endl;
        ssh_options_set(sshSession, SSH_OPTIONS_HOST, jobHostName.toAscii().data());
        // ssh_options_set(sshSession, SSH_OPTIONS_USER, "antoine");
        ssh_options_set(sshSession, SSH_OPTIONS_LOG_VERBOSITY, &verbosity);
        ssh_options_set(sshSession, SSH_OPTIONS_PORT, &port);
        std::cout << " Setting ssh options ... OK" << std::endl;

        std::cout << " Connecting ssh ... " << std::endl;
        int connectionResponse = ssh_connect(sshSession);
        if (connectionResponse != SSH_OK)
        {
            fprintf(stderr, "Error connecting to host %s : %s\n", jobHostName.toAscii().data(),
                    ssh_get_error(sshSession));
            ssh_free(sshSession);
            exit(-1);
        }
        std::cout << " Connecting ssh ... OK" << std::endl;

        // TODO Authenticating the server
        // if (verify_knownhost(my_ssh_session) < 0)
        // {
        //     ssh_disconnect(my_ssh_session);
        //     ssh_free(my_ssh_session);
        //     exit(-1);
        // }

        // // TODO Authenticating the user
        // password = getpass("Password: ");
        // rc = ssh_userauth_password(my_ssh_session, NULL, password);
        // if (rc != SSH_AUTH_SUCCESS)
        // {
        //     fprintf(stderr, "Error authenticating with password: %s\n",
        //             ssh_get_error(my_ssh_session));
        //     ssh_disconnect(my_ssh_session);
        //     ssh_free(my_ssh_session);
        //     exit(-1);
        // }

        sftp_session sftpSession;
        int rc;
        std::cout << " Creating sftp session ... " << std::endl;
        sftpSession = sftp_new(sshSession);
        if (sftpSession == NULL)
        {
            fprintf(stderr, "Error allocating SFTP session: %s\n",
                    ssh_get_error(sshSession));
            return;// SSH_ERROR;
        }
        std::cout << " Creating sftp session ...OK " << std::endl;

        std::cout << " Init sftp session ... " << std::endl;
        rc = sftp_init(sftpSession);
        if (rc != SSH_OK)
        {
            // fprintf(stderr, "Error initializing SFTP session: %s\n",
                    // sftp_get_error(sftpSession));
            sftp_free(sftpSession);
            return;// rc;
        }
        std::cout << " Init sftp session ... OK" << std::endl;

        #define MAX_XFER_BUF_SIZE 16384

        int access_type;
        sftp_file remoteFile;
        char buffer[MAX_XFER_BUF_SIZE];
        int nbytes, nwritten, rc1;
        int fd;
        access_type = O_RDONLY;

        std::cout << " Opening sftp remoteFile ... " << std::endl;
        remoteFile = sftp_open(sftpSession, "/etc/profile",
                               access_type, 0);
        if (remoteFile == NULL) {
            fprintf(stderr, "Can't open remoteFile for reading: %s\n",
                    ssh_get_error(sshSession));
            return;// SSH_ERROR;
        }
        std::cout << " Opening sftp remoteFile ... OK" << std::endl;

        std::string localFileName = "/tmp/dimjcPID" + pidStr.toStdString() + "_" + jobHostName.toStdString() + ".log";
        std::cout << " Creating local file ... " << std::endl;
        fd = open(localFileName.c_str(), O_CREAT);
        if (fd < 0) {
            fprintf(stderr, "Can't open file for writing: %s\n",
                    strerror(errno));
            return;// SSH_ERROR;
        }
        std::cout << " Creating local file ...OK " << std::endl;

        std::cout << " Reading local file ... " << std::endl;
        for (;;) {
            nbytes = sftp_read(remoteFile, buffer, sizeof(buffer));
            if (nbytes == 0) {
                break; // EOF
            } else if (nbytes < 0) {
                fprintf(stderr, "Error while reading file: %s\n",
                        ssh_get_error(sshSession));
                sftp_close(remoteFile);
                return;// SSH_ERROR;
            }
            nwritten = write(fd, buffer, nbytes);
            if (nwritten != nbytes) {
                fprintf(stderr, "Error writing: %s\n",
                        strerror(errno));
                sftp_close(remoteFile);
                return;// SSH_ERROR;
            }
        }
        std::cout << " Reading local file ... OK" << std::endl;

        std::cout << " Closing sftp session ..." << std::endl;
        rc1 = sftp_close(remoteFile);
        if (rc1 != SSH_OK) {
            fprintf(stderr, "Can't close the read file: %s\n",
                    ssh_get_error(sshSession));
            return;// rc1;
        }
        std::cout << " Closing sftp session ... OK" << std::endl;

        std::cout << " Freeing sftp session ... " << std::endl;
        sftp_free(sftpSession);
        std::cout << " Freeing sftp session ... OK" << std::endl;


        std::cout << " Dumping localFile to widget ... " << std::endl;
        QFile file(QString::fromStdString(localFileName));
        if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            std::cout << " Error : could not open logFile, you may want to check access rights" << std::endl;
            return;
        }

        QTextStream in(&file);
        QString text;
        text = in.readAll();
        pLogFile->setText(text);
        file.close();
        pLogFile->show();
        std::cout << " Dumping localFile to widget ... OK" << std::endl;

        std::cout << " Disconnecting ssh session ... " << std::endl;
        ssh_disconnect(sshSession);
        std::cout << " Disconnecting ssh session ... OK" << std::endl;

        std::cout << " Freeing ssh session ... " << std::endl;
        ssh_free(sshSession);
        std::cout << " Freeing ssh session ... OK" << std::endl;

        */
    }
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::startHostJobs()
{
    QTreeWidgetItem* pSelectedItem = m_pTreeWidget->currentItem();

    if(!pSelectedItem)
        return;

    if(pSelectedItem->data(0, Qt::UserRole).value<int>() != HOST_ITEM)
        return;

    QString hostName = pSelectedItem->text(NAME);

    if(!this->jobControlExists(hostName.toStdString()))
    {
        popupMissingJobControl(hostName);
        return;
    }

    m_pJobIterface->startJobs(hostName.toStdString());
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::startSelectedJob()
{
    QTreeWidgetItem* pSelectedItem = m_pTreeWidget->currentItem();

    if(!pSelectedItem)
        return;

    if(pSelectedItem->data(0, Qt::UserRole).value<int>() != JOB_ITEM)
        return;

    QString hostName = pSelectedItem->parent()->text(NAME);
    QString jobName = pSelectedItem->text(NAME);

    if(!this->jobControlExists(hostName.toStdString()))
    {
        popupMissingJobControl(hostName);
        return;
    }

    m_pJobIterface->startJob(hostName.toStdString(), jobName.toStdString());
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::startAllJobs()
{
    const Json::Value &root(m_pJobIterface->getRoot());
    StringVector hostList = root["HOSTS"].getMemberNames();

    QStringList nonRunningJobControls = getNonRunningJobControls();

    if(!nonRunningJobControls.isEmpty())
        popupMissingJobControls(nonRunningJobControls);

    // loop over hosts
    for(StringVector::iterator iter = hostList.begin(), endIter = hostList.end() ;
            endIter != iter ; ++iter)
    {
        m_pJobIterface->startJobs(*iter);
    }
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::clearHostJobs()
{
    QTreeWidgetItem* pSelectedItem = m_pTreeWidget->currentItem();

    if(!pSelectedItem)
        return;

    if(pSelectedItem->data(0, Qt::UserRole).value<int>() != HOST_ITEM)
        return;

    QString hostName = pSelectedItem->text(NAME);

    if(!this->jobControlExists(hostName.toStdString()))
    {
        popupMissingJobControl(hostName);
        return;
    }

    m_pJobIterface->clearHostJobs(hostName.toStdString());
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::clearAllJobs()
{
    QStringList nonRunningJobControls = getNonRunningJobControls();

    if(!nonRunningJobControls.isEmpty())
        popupMissingJobControls(nonRunningJobControls);

    m_pJobIterface->clearAllJobs();
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::killSelectedJob()
{
    QComboBox* pKillItem = m_pKillComboBoxWidget;
    QTreeWidgetItem* pSelectedItem = m_pTreeWidget->currentItem();

    if(!pSelectedItem)
        return;

    if(pSelectedItem->data(0, Qt::UserRole).value<int>() != JOB_ITEM)
        return;

    QString hostName = pSelectedItem->parent()->text(NAME);
    QString pidStr = pSelectedItem->text(PID);
    QVariant sigVar = pKillItem->itemData(pKillItem->currentIndex());

    if(!this->jobControlExists(hostName.toStdString()))
    {
        popupMissingJobControl(hostName);
        return;
    }

    if(pidStr.isEmpty())
        return;

    uint32_t pid = pidStr.toUInt();
    uint32_t sig = sigVar.toUInt();

    m_pJobIterface->killJob(hostName.toStdString(), pid, sig);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::restartSelectedJob()
{
    QComboBox* pKillItem = m_pKillComboBoxWidget;
    QTreeWidgetItem* pSelectedItem = m_pTreeWidget->currentItem();

    if(!pSelectedItem)
        return;

    if(pSelectedItem->data(0, Qt::UserRole).value<int>() != JOB_ITEM)
        return;

    QString hostName = pSelectedItem->parent()->text(NAME);
    QString jobName = pSelectedItem->text(NAME);
    QString pidStr = pSelectedItem->text(PID);
    QVariant sigVar = pKillItem->itemData(pKillItem->currentIndex());

    if(!this->jobControlExists(hostName.toStdString()))
    {
        popupMissingJobControl(hostName);
        return;
    }

    if(pidStr.isEmpty())
        return;

    uint32_t pid = pidStr.toUInt();
    uint32_t sig = sigVar.toUInt();

    m_pJobIterface->restartJob(hostName.toStdString(), jobName.toStdString(), pid, sig);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::restartAllJobs()
{
    QComboBox* pKillItem = m_pKillComboBoxWidget;

    QStringList nonRunningJobControls = getNonRunningJobControls();

    if(!nonRunningJobControls.isEmpty())
        popupMissingJobControls(nonRunningJobControls);

    // loop over hosts and jobs
    // and restart them if the pid is defined
    for(unsigned int h=0 ; h<m_pTreeWidget->topLevelItemCount() ; h++)
    {
        QTreeWidgetItem *pHostItem = m_pTreeWidget->topLevelItem(h);

        QString hostName = pHostItem->text(NAME);

        for(unsigned int j=0 ; j<pHostItem->childCount() ; j++)
        {
            QTreeWidgetItem *pJobItem = pHostItem->child(j);

            QString jobName = pJobItem->text(NAME);
            QString pidStr = pJobItem->text(PID);
            QVariant sigVar = pKillItem->itemData(pKillItem->currentIndex());

            if(pidStr.isEmpty())
                continue;

            uint32_t pid = pidStr.toUInt();
            uint32_t sig = sigVar.toUInt();

            m_pJobIterface->restartJob(hostName.toStdString(), jobName.toStdString(), pid, sig);
        }
    }
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::updateJobStatus()
{
    m_pJobIterface->status();

    struct timespec timesleep;
    timesleep.tv_sec = 0;
    timesleep.tv_nsec = 500000000L;
    nanosleep(&timesleep, NULL);

    this->updateStatus(m_pJobIterface->getProcessStatusValue());
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::loadJson(const Json::Value &root)
{
    m_pTreeWidget->clear();

    StringVector hostList = root["HOSTS"].getMemberNames();

    // loop over hosts
    for(StringVector::iterator iter = hostList.begin(), endIter = hostList.end() ;
            endIter != iter ; ++iter)
    {
        const Json::Value &host(root["HOSTS"][*iter]);

        QStringList name((*iter).c_str());

        QTreeWidgetItem *pHostItem = new QTreeWidgetItem(name);

        pHostItem->setData(0, Qt::UserRole, HOST_ITEM);
        m_pTreeWidget->addTopLevelItem(pHostItem);

        // loop over jobs host
        for(unsigned int j=0 ; j<host.size() ; j++)
        {
            QStringList jobHeader;
            jobHeader << host[j]["NAME"].asString().c_str() << host[j]["PROGRAM"].asString().c_str() << host[j]["PID"].asString().c_str() << host[j]["STATUS"].asString().c_str() ;

            QTreeWidgetItem *pJobItem = new QTreeWidgetItem(jobHeader);

            pJobItem->setData(NAME, Qt::UserRole, JOB_ITEM);
            pJobItem->setData(PROG_NAME, Qt::UserRole, JOB_PROGRAM_NAME_ITEM);
            pJobItem->setData(PID, Qt::UserRole, JOB_PID_ITEM);
            pJobItem->setData(STATUS, Qt::UserRole, JOB_STATUS_ITEM);

            pHostItem->addChild(pJobItem);

            QTreeWidgetItem *pEnvironmentItem = new QTreeWidgetItem(QStringList("ENV"));
            pEnvironmentItem->setData(0, Qt::UserRole, JOB_ENV_ITEM);
            pJobItem->addChild(pEnvironmentItem);

            const Json::Value &envJsonValue = host[j]["ENV"];

            for(unsigned int e=0 ; e<envJsonValue.size() ; e++)
            {
                QString env(envJsonValue[e].asString().c_str());

                QStringList envVarHeader;
                envVarHeader << env;

                QTreeWidgetItem *pEnvVarItem = new QTreeWidgetItem(envVarHeader);
                pEnvVarItem->setData(0, Qt::UserRole, VARIABLE_ITEM);
                pEnvironmentItem->addChild(pEnvVarItem);
            }

            QTreeWidgetItem *pArgsItem = new QTreeWidgetItem(QStringList("ARGS"));
            pArgsItem->setData(0, Qt::UserRole, JOB_ARGS_ITEM);
            pJobItem->addChild(pArgsItem);

            const Json::Value &argsJsonValue = host[j]["ARGS"];

            for(unsigned int e=0 ; e<argsJsonValue.size() ; e++)
            {
                QString arg(argsJsonValue[e].asString().c_str());

                QStringList argVarHeader;
                argVarHeader << arg;

                QTreeWidgetItem *pArgVarItem = new QTreeWidgetItem(argVarHeader);
                pArgVarItem->setData(0, Qt::UserRole, VARIABLE_ITEM);
                pArgsItem->addChild(pArgVarItem);
            }
        }

        pHostItem->setExpanded(true);
    }

    m_pTreeWidget->header()->resizeSections(QHeaderView::Stretch);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::updateStatus(const Json::Value &value)
{
    QMap<QString, QColor> stateToColorMap;
    stateToColorMap["Z"] = QColor(Qt::red); // zombie
    stateToColorMap["T"] = QColor(Qt::darkRed); // traced or stopped
    stateToColorMap["R"] = QColor(Qt::green); // running
    stateToColorMap["D"] = QColor(Qt::darkGreen); // un-interruptible sleep
    stateToColorMap["S"] = QColor(Qt::darkGreen); // interruptible sleep
    stateToColorMap["X"] = QColor(Qt::red); // interruptible sleep

    for(unsigned int i=0 ; i<m_pTreeWidget->topLevelItemCount() ; i++)
    {
        QTreeWidgetItem *pHostItem = m_pTreeWidget->topLevelItem(i);

        std::string hostName = pHostItem->text(NAME).toStdString();

        for(unsigned int j=0 ; j<pHostItem->childCount() ; j++)
        {
            QTreeWidgetItem *pJobItem = pHostItem->child(j);

            std::string jobName = pJobItem->text(NAME).toStdString();

            bool found = false;

            for(unsigned int v=0 ; v<value.size() ; v++)
            {
                std::string vHost = value[v]["HOST"].asString();
                std::string vJobName = value[v]["NAME"].asString();
                uint32_t vJobPid = value[v]["PID"].asUInt();
                std::string vJobStatus = value[v]["STATUS"].asString();

                if(vHost == hostName && vJobName == jobName)
                {
                    pJobItem->setText(STATUS, QString(vJobStatus.c_str()).trimmed());
                    pJobItem->setText(PID, QString::number(vJobPid));

                    found = true;
                    break;
                }
            }

            if(!found)
            {
                pJobItem->setText(STATUS, "X (dead)");
                pJobItem->setText(PID, "");
            }

            // cases available in /proc/pid/status file
            QMap<QString, QColor>::iterator findIter = stateToColorMap.find(pJobItem->text(STATUS).at(0));

			if(findIter != stateToColorMap.end())
                pJobItem->setData(STATUS, Qt::ForegroundRole, QBrush(findIter.value()));
            else
                pJobItem->setData(STATUS, Qt::ForegroundRole, QBrush(Qt::black));
        }

    }

    m_pTreeWidget->header()->resizeSections(QHeaderView::Stretch);
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::handleAutomaticModeButtonClicked()
{
	if(m_pJobIterface->started())
    {
        m_pJobIterface->stopUpdate();
        m_pAutomaticModeButton->setText("Start");
    }
    else
    {
        int nSeconds = m_pUpdatePeriodSpinBox->value();
        m_pJobIterface->startUpdate(nSeconds);
        m_pAutomaticModeButton->setText("Stop");
    }
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::handleAutomaticModeValueChanged(int value)
{
	if(m_pJobIterface->started())
    {
        m_pJobIterface->stopUpdate();
        m_pJobIterface->startUpdate(value);
    }
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::updateStatus(const QString &hostName)
{
    const Json::Value value = m_pJobIterface->processStatus(hostName.toStdString())["JOBS"];
    QTreeWidgetItem *pHostItem = 0;

    for(unsigned int i=0 ; i<m_pTreeWidget->topLevelItemCount() ; i++)
    {
        QTreeWidgetItem *pItem = m_pTreeWidget->topLevelItem(i);

        if(hostName == pItem->text(NAME))
            pHostItem = pItem;
    }

    if(!pHostItem)
        return;

    QMap<QString, QColor> stateToColorMap;
    stateToColorMap["Z"] = QColor(Qt::red); // zombie
    stateToColorMap["T"] = QColor(Qt::darkRed); // traced or stopped
    stateToColorMap["R"] = QColor(Qt::green); // running
    stateToColorMap["D"] = QColor(Qt::darkGreen); // un-interruptible sleep
    stateToColorMap["S"] = QColor(Qt::darkGreen); // interruptible sleep
    stateToColorMap["X"] = QColor(Qt::red); // interruptible sleep

	for(unsigned int j=0 ; j<pHostItem->childCount() ; j++)
    {
        QTreeWidgetItem *pJobItem = pHostItem->child(j);

        std::string jobName = pJobItem->text(NAME).toStdString();

        bool found = false;

		for(unsigned int v=0 ; v<value.size() ; v++)
        {
            std::string vHost = value[v]["HOST"].asString();
            std::string vJobName = value[v]["NAME"].asString();
            uint32_t vJobPid = value[v]["PID"].asUInt();
            std::string vJobStatus = value[v]["STATUS"].asString();

			if(vJobName == jobName)
            {
                pJobItem->setText(STATUS, QString(vJobStatus.c_str()).trimmed());
                pJobItem->setText(PID, QString::number(vJobPid));

                found = true;
                break;
            }
        }

		if(!found)
        {
            pJobItem->setText(STATUS, "X (dead)");
            pJobItem->setText(PID, "");
        }

        // cases available in /proc/pid/status file
        QMap<QString, QColor>::iterator findIter = stateToColorMap.find(pJobItem->text(STATUS).at(0));

		if(findIter != stateToColorMap.end())
            pJobItem->setData(STATUS, Qt::ForegroundRole, QBrush(findIter.value()));
        else
            pJobItem->setData(STATUS, Qt::ForegroundRole, QBrush(Qt::black));
    }

    m_pTreeWidget->header()->resizeSections(QHeaderView::Stretch);
}

//-------------------------------------------------------------------------------------------------

bool DQMJobInterfaceWidget::jobControlExists(const std::string &hostName) const
{
    // Look for DB server
    DimBrowser browser;

    std::string jobControlName = "/DJC/" + hostName + "/JOBSTATUS";
    int nServices = browser.getServices(jobControlName.c_str());

    return (nServices != 0);
}

//-------------------------------------------------------------------------------------------------

QStringList DQMJobInterfaceWidget::getNonRunningJobControls() const
{
    QStringList missingJobControlList;

	for(int i=0 ; i<m_pTreeWidget->topLevelItemCount() ; i++)
    {
        QString hostName = m_pTreeWidget->topLevelItem(i)->text(0);

		if(!this->jobControlExists(hostName.toStdString()))
            missingJobControlList << hostName;
    }

    return missingJobControlList;
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::popupMissingJobControl(const QString &hostName)
{
    QMessageBox::warning(this, "Job control not running !",
                         "ERROR !\n\n"
                         "The job control on '" + hostName + "' is not running (or crashed).\n"
                         "Please, (re)start it !");
}

//-------------------------------------------------------------------------------------------------

void DQMJobInterfaceWidget::popupMissingJobControls(const QStringList &hostNameList)
{
    QString message = "ERROR !\n\n"
                      "The following job controls are not running (or crashed) : \n";

	for(int i=0 ; i<hostNameList.size() ; i++)
        message += "   * " + hostNameList.at(i) + "\n";

    message += "Please, check the job controls status on the different servers "
               "and restart them if needed";

    QMessageBox::warning(this, "Job controls not running !", message);
}

}

