  /// \file DQMMonitoringController.cc
/*
 *
 * DQMMonitoringController.cc source template automatically generated by a class generator
 * Creation date : lun. oct. 12 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/vis/DQMMonitoringController.h"
#include "dqm4hep/vis/DQMMonitoring.h"
#include "dqm4hep/vis/DQMMonitoringView.h"
#include "dqm4hep/vis/DQMMonitorElementView.h"
#include "dqm4hep/vis/DQMMonitoringModel.h"
#include "dqm4hep/vis/DQMGuiMonitorElementClient.h"
#include "dqm4hep/vis/DQMCanvas.h"
#include "dqm4hep/vis/DQMRootWidget.h"
#include "dqm4hep/vis/DQMCanvasArea.h"
#include "dqm4hep/vis/DQMBrowserWidget.h"
#include "dqm4hep/vis/DQMMonitorElementInfoWidget.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "DQMCoreConfig.h"
#include "DQMVizConfig.h"

#include <QMap>
#include <QDir>
#include <QDesktopServices>
#include <QUrl>
#include <QMessageBox>
#include <QStatusBar>
#include <QMainWindow>
#include <QFileDialog>
#include <QApplication>

#include <TFile.h>
#include <TCanvas.h>
#include <TH1.h>

// -- std headers
#include <unistd.h> // fork
#include <errno.h> // errno

namespace dqm4hep
{

DQMMonitoringController::DQMMonitoringController(DQMMonitoring *pMonitoring) :
	m_pMonitoring(pMonitoring),
	m_updateMode(false)
{
	m_pMonitoring->setController(this);

	m_logLevelToTextMap.insert(DEBUG, "[DEBUG] ");
	m_logLevelToTextMap.insert(MESSAGE, "[MESSAGE] ");
	m_logLevelToTextMap.insert(WARNING, "[WARNING] ");
	m_logLevelToTextMap.insert(ERROR, "[ERROR] ");
}

//-------------------------------------------------------------------------------------------------

DQMMonitoringController::~DQMMonitoringController()
{
	clear();
}

//-------------------------------------------------------------------------------------------------

DQMMonitoring *DQMMonitoringController::getMonitoring() const
{
	return m_pMonitoring;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::log(const std::string &message)
{
	this->log(MESSAGE, message);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::log(LogLevel level, const std::string &message)
{
	this->getMonitoring()->getView()->log(level, message);
}

//-------------------------------------------------------------------------------------------------

DQMGuiMonitorElementClient *DQMMonitoringController::createClient(const std::string &collectorName)
{
	return new DQMGuiMonitorElementClient(collectorName);
}

//-------------------------------------------------------------------------------------------------

DQMGuiMonitorElementClient *DQMMonitoringController::getClient(const std::string &collectorName)
{
	DQMGuiMonitorElementClientMap::iterator findIter = m_clientMap.find(collectorName);

	if(m_clientMap.end() != findIter)
		return findIter->second;

	DQMGuiMonitorElementClient *pNewClient = this->createClient(collectorName);

	// to receive monitor elements
	connect(pNewClient, SIGNAL(monitorElementPublicationReceived(const DQMPublication &)),
			this, SLOT(receiveMonitorElementPublication(const DQMPublication &)));

	// to receive new available monitor elements
	connect(pNewClient, SIGNAL(monitorElementsAvailable(const DQMMonitorElementInfoList &)),
			this, SLOT(receiveAvailableMonitorElements(const DQMMonitorElementInfoList &)));

	// to handle server startup
	connect(pNewClient, SIGNAL(onServerStartup()), this, SLOT(handleServerStartup()));

	// to handle server shutdown
	connect(pNewClient, SIGNAL(onServerShutdown()), this, SLOT(handleServerShutdown()));

	m_clientMap.insert(DQMGuiMonitorElementClientMap::value_type(collectorName, pNewClient));

	pNewClient->getMonitorElementClient()->setUpdateMode(m_updateMode);
	return pNewClient;
}

//-------------------------------------------------------------------------------------------------

DQMGuiMonitorElementClient *DQMMonitoringController::findClient(const std::string &collectorName)
{
	DQMGuiMonitorElementClientMap::iterator findIter = m_clientMap.find(collectorName);

	if(m_clientMap.end() != findIter)
		return findIter->second;

	return NULL;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::removeClient(const std::string &collectorName)
{
	DQMGuiMonitorElementClientMap::iterator findIter = m_clientMap.find(collectorName);

	if(m_clientMap.end() != findIter)
	{
		DQMGuiMonitorElementClient *pClient = findIter->second;
		delete pClient; // delete also calls disconnectFromService()
		m_clientMap.erase(findIter);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::createEmptyMonitorElements(const std::string &collectorName, const DQMMonitorElementInfoList &nameList)
{
	this->getMonitoring()->getModel()->loadMonitorElementInfoList(collectorName, nameList);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::subscribe(const std::string &collectorName, const DQMMonitorElementRequest &request)
{
	if(collectorName.empty() || request.empty())
		return;

	DQMGuiMonitorElementClient *pGuiClient = this->getClient(collectorName);
	DQMMonitorElementClient *pClient = pGuiClient->getMonitorElementClient();

	if(!pClient->isConnectedToService())
		pClient->connectToService();

	StatusCode statusCode = pClient->subscribe(request);

	if(STATUS_CODE_SUCCESS != statusCode)
		this->log(ERROR, "Couldn't send subscription to collector " + collectorName + " : " + statusCodeToString(statusCode));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::unsubscribe(const std::string &collectorName, const DQMMonitorElementRequest &request)
{
	if(collectorName.empty() || request.empty())
		return;

	DQMGuiMonitorElementClient *pGuiClient = this->getClient(collectorName);
	DQMMonitorElementClient *pClient = pGuiClient->getMonitorElementClient();

	if(!pClient->isConnectedToService())
		pClient->connectToService();

	StatusCode statusCode = pClient->unsubscribe(request);

	if(STATUS_CODE_SUCCESS != statusCode)
		this->log(ERROR, "Couldn't send un-subscription to collector " + collectorName + " : " + statusCodeToString(statusCode));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::querySubscribedMonitorElements()
{
	int nCollectorErrors = 0;

	for(DQMGuiMonitorElementClientMap::iterator iter = m_clientMap.begin(), endIter = m_clientMap.end() ;
			endIter != iter ; ++iter)
	{
		StatusCode statusCode = iter->second->getMonitorElementClient()->querySubscribedMonitorElements();

		if(STATUS_CODE_SUCCESS != statusCode)
			nCollectorErrors++;
	}

	if(nCollectorErrors != 0)
		this->log(ERROR, "Couldn't send update request to collectors (" + DQM4HEP::typeToString(nCollectorErrors) + " errors)");
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::querySubscribedMonitorElements(const std::string &collectorName)
{
	if(collectorName.empty())
		return;

	DQMGuiMonitorElementClient *pGuiClient = this->getClient(collectorName);
	DQMMonitorElementClient *pClient = pGuiClient->getMonitorElementClient();

	if(!pClient->isConnectedToService())
		pClient->connectToService();

	StatusCode statusCode = pClient->querySubscribedMonitorElements();

	if(STATUS_CODE_SUCCESS != statusCode)
		this->log(ERROR, "Couldn't send un-subscription request to collector " + collectorName + " : " + statusCodeToString(statusCode));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::querySubscribedMonitorElements(const std::string &collectorName, const DQMMonitorElementRequest &request)
{
	if(collectorName.empty())
		return;

	DQMGuiMonitorElementClient *pGuiClient = this->getClient(collectorName);
	DQMMonitorElementClient *pClient = pGuiClient->getMonitorElementClient();

	if(!pClient->isConnectedToService())
		pClient->connectToService();

	StatusCode statusCode = pClient->querySubscribedMonitorElements(request);

	if(STATUS_CODE_SUCCESS != statusCode)
		this->log(ERROR, "Couldn't send un-subscription request to collector " + collectorName + " : " + statusCodeToString(statusCode));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::unsubscribe(const std::string &collectorName)
{
	if(collectorName.empty())
		return;

	DQMGuiMonitorElementClient *pGuiClient = this->getClient(collectorName);
	DQMMonitorElementClient *pClient = pGuiClient->getMonitorElementClient();

	if(!pClient->isConnectedToService())
		pClient->connectToService();

	// empty subscription request to clear subscriptions
	DQMMonitorElementRequest request;
	StatusCode statusCode = pClient->replaceSubscription(request);

	if(STATUS_CODE_SUCCESS != statusCode)
		this->log(ERROR, "Couldn't send un-subscription request to collector " + collectorName + " : " + statusCodeToString(statusCode));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::setUpdateMode(bool updateMode)
{
	for(DQMGuiMonitorElementClientMap::iterator iter = m_clientMap.begin(), endIter = m_clientMap.end() ;
			endIter != iter ; ++iter)
		iter->second->getMonitorElementClient()->setUpdateMode(updateMode);

	m_updateMode = updateMode;
}

//-------------------------------------------------------------------------------------------------

bool DQMMonitoringController::getUpdateMode() const
{
	return m_updateMode;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::queryUpdate(DQMGuiMonitorElement *pMonitorElement)
{
	std::string fullName = (pMonitorElement->getMonitorElement()->getPath() + pMonitorElement->getMonitorElement()->getName()).getPath();
	std::string moduleName = pMonitorElement->getMonitorElement()->getModuleName();
	std::string collectorName = pMonitorElement->getMonitorElement()->getCollectorName();

	DQMMonitorElementRequest request;
	request.insert(DQMMonitorElementRequest::value_type(moduleName, fullName));

	this->querySubscribedMonitorElements(collectorName, request);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::queryUpdate(const DQMGuiMonitorElementList &monitorElementList)
{
	DQMMonitorElementRequest request;
	std::map<std::string, DQMMonitorElementRequest> requestMap;

	for(DQMGuiMonitorElementList::const_iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter)
	{
		std::string fullName = ((*iter)->getMonitorElement()->getPath() + (*iter)->getMonitorElement()->getName()).getPath();
		std::string moduleName = (*iter)->getMonitorElement()->getModuleName();
		std::string collectorName = (*iter)->getMonitorElement()->getCollectorName();

		requestMap[collectorName].insert(DQMMonitorElementRequest::value_type(moduleName, fullName));
	}

	for(std::map<std::string, DQMMonitorElementRequest>::iterator iter = requestMap.begin(), endIter = requestMap.end() ;
			endIter != iter ; ++iter)
	{
		this->querySubscribedMonitorElements(iter->first, iter->second);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::receiveMonitorElementPublication(const DQMPublication &publication)
{
	for(DQMPublication::const_iterator iter = publication.begin(), endIter = publication.end() ;
			endIter != iter ; ++iter)
	{
		std::string moduleName = iter->first;

		for(int i=0 ; i<iter->second.size() ; i++)
		{
			DQMMonitorElementPtr monitorElement = iter->second.at(i);
			this->getMonitoring()->getModel()->updateMonitorElement(monitorElement);
		}
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::receiveAvailableMonitorElements(const DQMMonitorElementInfoList &infoList)
{
	DQMGuiMonitorElementClient *pGuiClient = qobject_cast<DQMGuiMonitorElementClient *>( sender() );

	if( ! pGuiClient )
		return;

	DQMMonitorElementClient *pClient = pGuiClient->getMonitorElementClient();

	if( ! pClient->isConnectedToService() )
		return;

	QString collectorName = pClient->getCollectorName().c_str();
	QSet<QString> moduleNameSet;

	// get module list
	for(auto iter = infoList.begin(), endIter = infoList.end() ;
			endIter != iter ; ++iter)
		moduleNameSet << iter->find( DQMKey::MODULE_NAME )->second.c_str();

	DQMMonitorElementView *pMeView = this->getMonitoring()->getView()->getMonitorElementView();
	QStringList moduleNameList(moduleNameSet.toList());
	DQMMonitorElementRequest request;

	for(unsigned int i=0 ; i<moduleNameList.size() ; i++)
	{
		QList<QTreeWidgetItem *> items = pMeView->getCheckedMonitorElements(collectorName.toStdString(), moduleNameList.at(i).toStdString());

		for(int j=0 ; j<items.size() ; j++)
		{
			DQMMonitorElementNavigator *pNavigator = qobject_cast<DQMMonitorElementNavigator *>(items.at(j)->treeWidget());

			std::string moduleName = pNavigator->getModuleName(items.at(j)).toStdString();
			std::string path = pNavigator->getFullPathName(items.at(j)).toStdString();
			std::string name = items.at(j)->text(0).toStdString();
			std::string fullName = (DQMPath(path) + name).getPath();

			request.insert(DQMMonitorElementRequest::value_type(moduleName, fullName));
		}
	}

	if( ! request.empty() )
		pClient->replaceSubscription(request);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::handleServerStartup()
{
	DQMGuiMonitorElementClient *pGuiClient = qobject_cast<DQMGuiMonitorElementClient *>(sender());

	if(!pGuiClient)
		return;

	DQMMonitorElementClient *pClient = pGuiClient->getMonitorElementClient();
	std::string collectorName = pClient->getCollectorName();

	// get all subscribed elements
	DQMMonitorElementView *pMeView = this->getMonitoring()->getView()->getMonitorElementView();
//	pMeView->enableSubscription(collectorName, true);
	QList<QTreeWidgetItem *> items = pMeView->getCheckedMonitorElements(collectorName);

	DQMMonitorElementRequest request;

	for(int j=0 ; j<items.size() ; j++)
	{
		DQMMonitorElementNavigator *pNavigator = qobject_cast<DQMMonitorElementNavigator *>(items.at(j)->treeWidget());

		std::string moduleName = pNavigator->getModuleName(items.at(j)).toStdString();
		std::string path = pNavigator->getFullPathName(items.at(j)).toStdString();
		std::string name = items.at(j)->text(0).toStdString();
		std::string fullName = (DQMPath(path) + name).getPath();

		request.insert(DQMMonitorElementRequest::value_type(moduleName, fullName));
	}

	if(!pClient->isConnectedToService())
		pClient->connectToService();

	pClient->setUpdateMode(m_updateMode);
	pClient->replaceSubscription(request);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::handleServerShutdown()
{
	DQMGuiMonitorElementClient *pGuiClient = qobject_cast<DQMGuiMonitorElementClient *>(sender());

	if(!pGuiClient)
		return;

	DQMMonitorElementClient *pClient = pGuiClient->getMonitorElementClient();
	std::string collectorName = pClient->getCollectorName();

	QMessageBox::warning(this->getMonitoring()->getView()->getMainWindow(),
			"Collector shutdown",
			QString("The following monitor element collector was shut down :\n\n"
			"* %1\n\n"
			"If you need to restart it, type in a terminal :\n"
			"  dqm4hep_start_monitor_element_collector -c %1 \n"
			"or restart it from the job control.").arg(collectorName.c_str()));

//	DQMMonitorElementView *pMeView = this->getMonitoring()->getView()->getMonitorElementView();
//	pMeView->uncheckAllMonitorElements(collectorName);
//	pMeView->enableSubscription(collectorName, false);
}

//-------------------------------------------------------------------------------------------------

QColor DQMMonitoringController::getColor(DQMQuality quality) const
{
	QMap<DQMQuality, QColor> colorPalette;

	colorPalette.insert(NO_QUALITY, QColor(Qt::gray));
	colorPalette.insert(VERY_BAD_QUALITY, QColor(Qt::darkRed));
	colorPalette.insert(BAD_QUALITY, QColor(Qt::darkYellow));
	colorPalette.insert(NORMAL_QUALITY, QColor(Qt::black));
	colorPalette.insert(GOOD_QUALITY, QColor(Qt::darkBlue));
	colorPalette.insert(VERY_GOOD_QUALITY, QColor(Qt::darkGreen));

	QMap<DQMQuality, QColor>::const_iterator findIter = colorPalette.find(quality);

	if(colorPalette.end() == findIter)
		return colorPalette[NO_QUALITY];

	return findIter.value();
}

//-------------------------------------------------------------------------------------------------

QIcon DQMMonitoringController::getIcon(DQMQuality quality) const
{
	QMap<DQMQuality, QIcon> iconMap;
	QString iconDir = QString(DQMViz_DIR) + "/icons/";

	iconMap.insert(NO_QUALITY,        QIcon(iconDir + "ME_N.xpm"));
	iconMap.insert(VERY_BAD_QUALITY,  QIcon(iconDir + "ME_VB.xpm"));
	iconMap.insert(BAD_QUALITY,       QIcon(iconDir + "ME_B.xpm"));
	iconMap.insert(NORMAL_QUALITY,    QIcon(iconDir + "ME_N.xpm"));
	iconMap.insert(GOOD_QUALITY,      QIcon(iconDir + "ME_G.xpm"));
	iconMap.insert(VERY_GOOD_QUALITY, QIcon(iconDir + "ME_VG.xpm"));

	QMap<DQMQuality, QIcon>::const_iterator findIter = iconMap.find(quality);

	if(iconMap.end() == findIter)
		return iconMap[NO_QUALITY];

	return findIter.value();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openFile()
{
    QString fileName = QFileDialog::getOpenFileName(this->getMonitoring()->getView()->getMainWindow(), tr("Import file"),
                    QString(""),
                    "XML files (*.xml)");

    if(fileName.isEmpty())
            return;

	this->openFile(fileName.toStdString());
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openFile(const std::string &fileName)
{
	TiXmlDocument document(fileName);

	if(!document.LoadFile())
	{
		QMessageBox::warning(this->getMonitoring()->getView()->getMainWindow(),
				"XML Import",
				"Couldn't import selection from xml file :\n\n"
				"* Invalid XML file content");

		return;
	}

	TiXmlHandle documentHandle(&document);
	TiXmlElement *pRootElement = documentHandle.FirstChildElement().Element();

	if(!pRootElement)
	{
		QMessageBox::warning(this->getMonitoring()->getView()->getMainWindow(),
				"XML Import",
				"Couldn't import selection from xml file :\n\n"
				"* No root element found");

		return;
	}

	TiXmlHandle rootHandle(pRootElement);

	TiXmlElement *pMonitoringElement = rootHandle.FirstChild("monitoring").Element();

	if(!pMonitoringElement)
	{
		QMessageBox::warning(this->getMonitoring()->getView()->getMainWindow(),
				"XML Import",
				"Couldn't import selection from xml file :\n\n"
				"* No <monitoring> element found");

		return;
	}

	TiXmlHandle monitoringHandle(pMonitoringElement);

	this->clear();
	this->getMonitoring()->getModel()->clear();
	this->getMonitoring()->getView()->clear();

	TiXmlElement *pDimDnsNodeElement = monitoringHandle.FirstChild("dimDnsNode").Element();

	if(pDimDnsNodeElement)
	{
		std::string dimDnsNode;

		if(!pDimDnsNodeElement->QueryStringAttribute("value", &dimDnsNode))
			DimClient::setDnsNode(dimDnsNode.c_str());
	}

	TiXmlElement *pViewElement = monitoringHandle.FirstChild("view").Element();

	if(pViewElement)
		this->getMonitoring()->getView()->fromXml(pViewElement);

	TiXmlElement *pControllerElement = monitoringHandle.FirstChild("controller").Element();

	if(pControllerElement)
	{
		TiXmlHandle controllerHandle(pControllerElement);

        for (TiXmlElement *pCollectorElement = controllerHandle.FirstChild("collector").Element(); NULL != pCollectorElement;
        		pCollectorElement = pCollectorElement->NextSiblingElement("collector"))
        {
        	std::string collectorName;
            if(pCollectorElement->QueryStringAttribute("name", &collectorName))
                continue;

            this->getClient(collectorName);
        }
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::saveAs()
{
    QString fileName = QFileDialog::getSaveFileName(this->getMonitoring()->getView()->getMainWindow(), tr("Export file"),
                    QString(""),
                    "XML files (*.xml)");

    if(fileName.isEmpty())
            return;

	this->saveAs(fileName.toStdString());
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::saveAs(const std::string &fileName) const
{
	if(fileName.empty())
		return;

	TiXmlDocument document;

	TiXmlDeclaration *pDeclaration = new TiXmlDeclaration( "1.0", "", "" );
	document.LinkEndChild(pDeclaration);

	TiXmlElement *pRootElement = new TiXmlElement("dqm4hep");
	document.LinkEndChild(pRootElement);

	TiXmlElement *pMonitoringElement = new TiXmlElement("monitoring");
	pRootElement->LinkEndChild(pMonitoringElement);

	TiXmlElement *pDimDnsNodeElement = new TiXmlElement("dimDnsNode");
	pMonitoringElement->LinkEndChild(pDimDnsNodeElement);
	pDimDnsNodeElement->SetAttribute("value", DimClient::getDnsNode());

	TiXmlElement *pViewElement = this->getMonitoring()->getView()->toXml();

	if(pViewElement)
		pMonitoringElement->LinkEndChild(pViewElement);

	TiXmlElement *pControllerElement = new TiXmlElement("controller");

	for(DQMGuiMonitorElementClientMap::const_iterator iter = m_clientMap.begin(), endIter = m_clientMap.end() ;
			endIter != iter ; ++iter)
	{
		const std::string &collectorName = iter->first;

		TiXmlElement *pCollectorElement = new TiXmlElement("collector");
		pControllerElement->LinkEndChild(pCollectorElement);
		pCollectorElement->SetAttribute("value", collectorName);
	}

	pMonitoringElement->LinkEndChild(pControllerElement);

	document.SaveFile(fileName);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openBrowser()
{
	DQMBrowserWidget *pBrowser = new DQMBrowserWidget(this->getMonitoring());

	pBrowser->setWindowTitle("DQM Browser");

	QString iconDir = QString(DQMViz_DIR) + "/icons";
	pBrowser->setWindowIcon(QIcon(iconDir + "/MON_BROWSER.png"));
	pBrowser->setAttribute(Qt::WA_DeleteOnClose, true);
	pBrowser->show();

	QObject::connect(this->getMonitoring()->getView()->getMainWindow(), SIGNAL(destroyed()), pBrowser, SLOT(close()));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::aboutDQM4HEP()
{
	QString iconDir = QString(DQMViz_DIR) + "/icons";


	QStringList authorList;

	authorList << "R. Ete , IPNL"
			<< "A. Pingault, GHENT"
			<< "L. Mirabito, IPNL";

	QString text;

	text += "DQMHEP : Data Quality Monitoring for High Energy Physics\n\n";
	text += "Version : "+ QString(DQMViz_VERSION_STR) + "\n\n";

	text += "DQM4HEP is free software: you can redistribute it and/or modify ";
	text +=	"it under the terms of the GNU General Public License as published by";
	text +=	"the Free Software Foundation, either version 3 of the License, or";
	text +=	"(at your option) any later version.\n\n";

	text +=	"DQM4HEP is distributed in the hope that it will be useful,";
	text +=	"but WITHOUT ANY WARRANTY; without even the implied warranty of";
	text +=	"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the";
	text +=	"GNU General Public License for more details.\n\n";

	text +=	"You should have received a copy of the GNU General Public License";
	text +=	"along with DQM4HEP. If not, see <http://www.gnu.org/licenses/>.\n\n";

	text += "Authors :\n";
	text += "  * R. Ete , IPNL\n";
	text += "  * A. Pingault, Ghent University\n";
	text += "  * L. Mirabito, IPNL\n\n";

	text += "Please, send comments or report bug via the github interface ";
	text += "<https://github.com/DQM4HEP/DQMViz/issues>";

	QMessageBox *pMessageBox = new QMessageBox(this->getMonitoring()->getView()->getMainWindow());
	pMessageBox->setWindowTitle("About DQM4HEP");
	pMessageBox->setIconPixmap(QPixmap(iconDir + "/MON_WIN.png").scaled(QSize(100, 100), Qt::KeepAspectRatioByExpanding));
	pMessageBox->setText(text);

	pMessageBox->exec();
	pMessageBox->deleteLater();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openDoxygenDoc()
{
	QString indexHtml;
	indexHtml += DQMCore_DIR;
	indexHtml += "/doc/html/index.html";

	QDir dir;
	if(!dir.exists(indexHtml))
	{
		QMessageBox::information(this->getMonitoring()->getView()->getMainWindow(),
				"Not found",
				"DQM4HEP was not built with Doxygen documentation. Sorry !");
		return;
	}

	QDesktopServices::openUrl(QUrl::fromLocalFile(indexHtml));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openUserGuide()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openGithubPage()
{
	QDesktopServices::openUrl(QUrl("https://github.com/DQM4HEP"));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openIssuesPage()
{
	QDesktopServices::openUrl(QUrl("https://github.com/DQM4HEP/DQMViz/issues"));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openMonitorElementInfo(DQMGuiMonitorElement *pGuiMonitorElement) const
{
	QDialog *pDialog = new QDialog();
	pDialog->setWindowTitle("Monitor element info (" + QString(pGuiMonitorElement->getMonitorElement()->getName().c_str()) + ")");

	QHBoxLayout *pLayout = new QHBoxLayout();
	pDialog->setLayout(pLayout);

	DQMMonitorElementInfoWidget *pMEInfoWidget = new DQMMonitorElementInfoWidget(pGuiMonitorElement);
	pMEInfoWidget->showTab(DQMMonitorElementInfoWidget::MONITOR_ELEMENT_INFO);

	pLayout->addWidget(pMEInfoWidget);

	pDialog->exec();
	pDialog->deleteLater();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openQualityTestResults(DQMGuiMonitorElement *pGuiMonitorElement) const
{
	QDialog *pDialog = new QDialog();
	pDialog->setWindowTitle("Monitor element info (" + QString(pGuiMonitorElement->getMonitorElement()->getName().c_str()) + ")");

	QHBoxLayout *pLayout = new QHBoxLayout();
	pDialog->setLayout(pLayout);

	DQMMonitorElementInfoWidget *pMEInfoWidget = new DQMMonitorElementInfoWidget(pGuiMonitorElement);
	pMEInfoWidget->showTab(DQMMonitorElementInfoWidget::QUALITY_TEST_RESULTS);

	pLayout->addWidget(pMEInfoWidget);

	pDialog->exec();
	pDialog->deleteLater();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openInROOTWindow(DQMGuiMonitorElement *pMonitorElement) const
{
	TObject *pObject = pMonitorElement->getMonitorElement()->getObject();

	if(!pObject)
		return;

	pid_t pid = fork();

	// parent process
	if(pid != 0)
		return;

	// child process
	char templateFile[] = "/tmp/canvasTmpXXXXXX.root";
	int ret = mkstemps(templateFile, 5);

	if(ret < 0)
		exit(-1);

	std::string tmpRootFileName = templateFile;
	TFile *pTmpRootFile = TFile::Open(tmpRootFileName.c_str(), "RECREATE");

	if(!pTmpRootFile)
		exit(1);

	// re-add the pave stats
	TH1 *pHistogram = (TH1*)pObject;

	if(pHistogram)
		pHistogram->SetStats(1);

	pTmpRootFile->cd();
	pObject->Write("dqm4hep_open_root_canvas");
	delete pTmpRootFile;

	// full program name
	std::string fullPathProg = std::string(DQMCore_DIR) + "/bin/dqm4hep_open_root_canvas";
	char executivePath[1000];
	memset(executivePath, 0, 1000);

	memcpy(executivePath, fullPathProg.c_str(), fullPathProg.size());

	// fill arguments
	const unsigned int maxNArgs = 100;
	const unsigned int maxMArgs = 1000;

	char argv[maxNArgs][maxMArgs];
	char *pArgv[maxNArgs];

	for(unsigned int i=0 ; i<maxNArgs ; i++)
		for(unsigned int j=0 ; j<maxMArgs ; j++)
			argv[i][j] = char(NULL);

	pArgv[0] = executivePath;
	sprintf(argv[1], "%s", "-f");
	pArgv[1] = & argv[1][0];
	sprintf(argv[2], "%s", tmpRootFileName.c_str());
	pArgv[2] = & argv[2][0];
	pArgv[3] = NULL;

	// fill environment
	const unsigned int maxNEnv = 10;
	const unsigned int maxMEnv = 1000;

	char env[maxNEnv][maxMEnv];
	char *pEnv[maxNEnv];

	for(unsigned int i=0 ; i<maxNEnv ; i++)
		for(unsigned int j=0 ; j<maxMEnv ; j++)
			env[i][j] = char(NULL);

	sprintf(env[0], "%s", "DISPLAY=:0");
	pEnv[0] = & env[0][0];
	pEnv[1] = NULL;

	// start root panel from dqm4hep specific executable
	int execveRet = execve(executivePath, pArgv, pEnv);

	LOG4CXX_ERROR( dqmMainLogger , "ERROR ! execve returned " << execveRet << " with errno set to " << errno );
	LOG4CXX_ERROR( dqmMainLogger , "Aborting" );

	exit(1);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::saveAs(DQMCanvasArea *pCanvasArea)
{
	QList<QMdiSubWindow*> subWindows = pCanvasArea->subWindowList();

	if(subWindows.isEmpty())
		return;

    QStringList formatList;
    QStringList extensionList;
    QString selectedFormat;

    formatList
//            << "Postscript (*.ps)"
//            << "Encapsulated Postscript (*.eps)"
//            << "PDF (*.pdf)"
//            << "GIF (*.gif)"
//            << "JPG (*.jpg)"
//            << "PNG (*.png)"
//            << "ROOT Macro (*.C)"
            << "ROOT Files (*.root)";

    extensionList
//            << ".ps"
//            << ".eps"
//            << ".pdf"
//            << ".gif"
//            << ".jpg"
//            << ".png"
//            << ".C"
            << ".root";

    QString fileName = QFileDialog::getSaveFileName(this->getMonitoring()->getView()->getMainWindow(),
    		"Save as",
            "",
            formatList.join(";;"),
            &selectedFormat);

    if(fileName.isEmpty())
    	return;

    int lastIndexOf = fileName.lastIndexOf(extensionList.at(formatList.indexOf(selectedFormat)));
    QString baseFileName;
    QString extensionFileName;

    if(lastIndexOf < 0)
    {
        lastIndexOf = fileName.size() -1;
        baseFileName = fileName;
        int index = formatList.indexOf(selectedFormat);
        extensionFileName = extensionList.at(index);
    }
    else
    {
        baseFileName = fileName.left(lastIndexOf);
        extensionFileName = fileName.right(fileName.size() - lastIndexOf);
    }

    std::string realFileName = (baseFileName + extensionFileName).toStdString();

    TFile *pFile = TFile::Open(realFileName.c_str(), "RECREATE");

    if(NULL == pFile)
    	return;

    for(int i=0 ; i<subWindows.count() ; i++)
    {
    	DQMCanvas *pCanvas = qobject_cast<DQMCanvas*>(subWindows.at(i));

    	if(!pCanvas)
    		continue;

    	DQMGuiMonitorElement *pGuiMonitorElement = pCanvas->getCurrentMonitorElement();

    	if( ! pGuiMonitorElement || ! pGuiMonitorElement->getMonitorElement() )
    		continue;

    	TObject *pObject = pGuiMonitorElement->getMonitorElement()->getObject();
    	pFile->WriteTObject(pObject, pObject->GetName());
    }

    pFile->Close();
    delete pFile;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::saveAs(DQMCanvas *pCanvas)
{
    QStringList formatList;
    QStringList extensionList;
    QString selectedFormat;

    formatList
            << "Postscript (*.ps)"
            << "Encapsulated Postscript (*.eps)"
            << "PDF (*.pdf)"
            << "GIF (*.gif)"
            << "JPG (*.jpg)"
            << "PNG (*.png)"
            << "ROOT Macro (*.C)"
            << "ROOT Files (*.root)";

    extensionList
            << ".ps"
            << ".eps"
            << ".pdf"
            << ".gif"
            << ".jpg"
            << ".png"
            << ".C"
            << ".root";

    QString fileName = QFileDialog::getSaveFileName(this->getMonitoring()->getView()->getMainWindow(),
    		"Save as",
            "",
            formatList.join(";;"),
            &selectedFormat);

    if(fileName.isEmpty())
    	return;

    int lastIndexOf = fileName.lastIndexOf(extensionList.at(formatList.indexOf(selectedFormat)));
    QString baseFileName;
    QString extensionFileName;

    if(lastIndexOf < 0)
    {
        lastIndexOf = fileName.size() -1;
        baseFileName = fileName;
        int index = formatList.indexOf(selectedFormat);
        extensionFileName = extensionList.at(index);
    }
    else
    {
        baseFileName = fileName.left(lastIndexOf);
        extensionFileName = fileName.right(fileName.size() - lastIndexOf);
    }

    std::string realFileName = (baseFileName + extensionFileName).toStdString();

    TFile *pFile = TFile::Open(realFileName.c_str(), "RECREATE");

    // save the canvas
	DQMGuiMonitorElement *pGuiMonitorElement = pCanvas->getCurrentMonitorElement();

	if( ! pGuiMonitorElement || ! pGuiMonitorElement->getMonitorElement() )
		return;

	TObject *pObject = pGuiMonitorElement->getMonitorElement()->getObject();
	pFile->WriteTObject(pObject, pObject->GetName());

	pFile->Close();
	delete pFile;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::clear()
{
	for(DQMGuiMonitorElementClientMap::iterator iter = m_clientMap.begin(), endIter = m_clientMap.end() ;
			endIter != iter ; ++iter)
	{
		iter->second->deleteLater();
	}

	m_clientMap.clear();
	m_updateMode = false;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::clearViewAndModel()
{
	this->getMonitoring()->getView()->clear();
	this->getMonitoring()->getModel()->clear();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::clearMonitoring()
{
	// first clear the client connections to avoid updates
	this->clear();

	// clear contents
	this->getMonitoring()->getView()->clear();
	this->getMonitoring()->getModel()->clear();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::quit()
{
	this->clearMonitoring();
	qApp->closeAllWindows();
	qApp->quit();
}

} 

