  /// \file DQMMonitoringController.cc
/*
 *
 * DQMMonitoringController.cc source template automatically generated by a class generator
 * Creation date : lun. oct. 12 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/vis/DQMMonitoringController.h"
#include "dqm4hep/vis/DQMMonitoring.h"
#include "dqm4hep/vis/DQMMonitoringView.h"
#include "dqm4hep/vis/DQMMonitorElementView.h"
#include "dqm4hep/vis/DQMMonitoringModel.h"
#include "dqm4hep/vis/DQMGuiMonitorElementClient.h"
#include "dqm4hep/vis/DQMCanvas.h"
#include "dqm4hep/vis/DQMRootWidget.h"
#include "dqm4hep/vis/DQMCanvasArea.h"
#include "dqm4hep/vis/DQMBrowserWidget.h"
#include "dqm4hep/vis/DQMMonitorElementInfoWidget.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMMessaging.h"
#include "DQMCoreConfig.h"
#include "DQMVizConfig.h"

#include <QMap>
#include <QDir>
#include <QDesktopServices>
#include <QUrl>
#include <QMessageBox>
#include <QStatusBar>
#include <QMainWindow>
#include <QFileDialog>
#include <QApplication>

#include <TFile.h>
#include <TCanvas.h>
#include <TH1.h>

// -- std headers
#include <unistd.h> // fork
#include <errno.h> // errno

namespace dqm4hep
{

DQMMonitoringController::DQMMonitoringController(DQMMonitoring *pMonitoring) :
	m_pMonitoring(pMonitoring)
{
	m_pMonitoring->setController(this);

	m_logLevelToTextMap.insert(DEBUG, "[DEBUG] ");
	m_logLevelToTextMap.insert(MESSAGE, "[MESSAGE] ");
	m_logLevelToTextMap.insert(WARNING, "[WARNING] ");
	m_logLevelToTextMap.insert(ERROR, "[ERROR] ");
}

//-------------------------------------------------------------------------------------------------

DQMMonitoringController::~DQMMonitoringController()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

DQMMonitoring *DQMMonitoringController::getMonitoring() const
{
	return m_pMonitoring;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::log(const std::string &message)
{
	this->log(MESSAGE, message);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::log(LogLevel level, const std::string &message)
{
	QString completeMessage = m_logLevelToTextMap.find(level).value() + message.c_str();
	this->getMonitoring()->getView()->getMainWindow()->statusBar()->showMessage(completeMessage, 2000);
}

//-------------------------------------------------------------------------------------------------

DQMGuiMonitorElementClient *DQMMonitoringController::createClient(const std::string &collectorName)
{
	return new DQMGuiMonitorElementClient(collectorName);
}

//-------------------------------------------------------------------------------------------------

DQMGuiMonitorElementClient *DQMMonitoringController::getClient(const std::string &collectorName)
{
	DQMGuiMonitorElementClientMap::iterator findIter = m_clientMap.find(collectorName);

	if(m_clientMap.end() != findIter)
		return findIter->second;

	DQMGuiMonitorElementClient *pNewClient = this->createClient(collectorName);
	connect(pNewClient, SIGNAL(monitorElementPublicationReceived(const DQMMonitorElementPublication &)),
			this, SLOT(handleMonitorElementPublicationReception(const DQMMonitorElementPublication &)));

	m_clientMap.insert(DQMGuiMonitorElementClientMap::value_type(collectorName, pNewClient));

	return pNewClient;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::removeClient(const std::string &collectorName)
{
	DQMGuiMonitorElementClientMap::iterator findIter = m_clientMap.find(collectorName);

	if(m_clientMap.end() != findIter)
	{
		DQMGuiMonitorElementClient *pClient = findIter->second;
		delete pClient; // delete also calls disconnectFromService()
		m_clientMap.erase(findIter);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::queryUpdate(DQMGuiMonitorElement *pMonitorElement)
{
	DQMGuiMonitorElementClient *pGuiClient = this->getClient(pMonitorElement->getMonitorElement()->getCollectorName());
	DQMMonitorElementClient *pClient = pGuiClient->getMonitorElementClient();

	if(!pClient->isConnectedToService())
		pClient->connectToService();

	std::string moduleName = pMonitorElement->getMonitorElement()->getModuleName();
	std::string name = pMonitorElement->getMonitorElement()->getName();
	const DQMPath &path = pMonitorElement->getMonitorElement()->getPath();
	std::string fullPathName = (path + name).getPath();

	DQMMonitorElementRequest request;
	request.m_requestList.push_back(DQMMonitorElementRequest::ModuleMonitorElementPair(moduleName, fullPathName));

	pClient->sendMonitorElementPublicationRequest(request);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::queryUpdate(const DQMGuiMonitorElementList &monitorElementList)
{
	std::map<DQMMonitorElementClient*, DQMMonitorElementRequest> clientToRequestMap;

	for(DQMGuiMonitorElementList::const_iterator iter = monitorElementList.begin(), endIter = monitorElementList.end() ;
			endIter != iter ; ++iter)
	{
		DQMGuiMonitorElement *pMonitorElement = *iter;

		DQMGuiMonitorElementClient *pGuiClient = this->getClient(pMonitorElement->getMonitorElement()->getCollectorName());
		DQMMonitorElementClient *pClient = pGuiClient->getMonitorElementClient();

		std::string moduleName = pMonitorElement->getMonitorElement()->getModuleName();
		std::string name = pMonitorElement->getMonitorElement()->getName();
		const DQMPath &path = pMonitorElement->getMonitorElement()->getPath();
		std::string fullPathName = (path + name).getPath();

		clientToRequestMap[pClient].m_requestList.push_back(DQMMonitorElementRequest::ModuleMonitorElementPair(moduleName, fullPathName));
	}

	for(std::map<DQMMonitorElementClient*, DQMMonitorElementRequest>::iterator iter = clientToRequestMap.begin(),
			endIter = clientToRequestMap.end() ; endIter != iter ; ++iter)
	{
		if(!iter->first->isConnectedToService())
			iter->first->connectToService();

		iter->first->sendMonitorElementPublicationRequest(iter->second);
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::clear()
{
	for(DQMGuiMonitorElementClientMap::iterator iter = m_clientMap.begin(), endIter = m_clientMap.end() ;
			endIter != iter ; ++iter)
	{
		iter->second->deleteLater();
	}

	m_clientMap.clear();
}

//-------------------------------------------------------------------------------------------------

QColor DQMMonitoringController::getColor(DQMQuality quality) const
{
	QMap<DQMQuality, QColor> colorPalette;

	colorPalette.insert(NO_QUALITY, QColor(Qt::gray));
	colorPalette.insert(VERY_BAD_QUALITY, QColor(Qt::darkRed));
	colorPalette.insert(BAD_QUALITY, QColor(Qt::darkYellow));
	colorPalette.insert(NORMAL_QUALITY, QColor(Qt::black));
	colorPalette.insert(GOOD_QUALITY, QColor(Qt::darkBlue));
	colorPalette.insert(VERY_GOOD_QUALITY, QColor(Qt::darkGreen));

	QMap<DQMQuality, QColor>::const_iterator findIter = colorPalette.find(quality);

	if(colorPalette.end() == findIter)
		return colorPalette[NO_QUALITY];

	return findIter.value();
}

//-------------------------------------------------------------------------------------------------

QIcon DQMMonitoringController::getIcon(DQMQuality quality) const
{
	QMap<DQMQuality, QIcon> iconMap;
	QString iconDir = QString(DQMViz_DIR) + "/icons/";

	iconMap.insert(NO_QUALITY,        QIcon(iconDir + "ME_N.xpm"));
	iconMap.insert(VERY_BAD_QUALITY,  QIcon(iconDir + "ME_VB.xpm"));
	iconMap.insert(BAD_QUALITY,       QIcon(iconDir + "ME_B.xpm"));
	iconMap.insert(NORMAL_QUALITY,    QIcon(iconDir + "ME_N.xpm"));
	iconMap.insert(GOOD_QUALITY,      QIcon(iconDir + "ME_G.xpm"));
	iconMap.insert(VERY_GOOD_QUALITY, QIcon(iconDir + "ME_VG.xpm"));

	QMap<DQMQuality, QIcon>::const_iterator findIter = iconMap.find(quality);

	if(iconMap.end() == findIter)
		return iconMap[NO_QUALITY];

	return findIter.value();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openFile()
{
    QString fileName = QFileDialog::getOpenFileName(this->getMonitoring()->getView()->getMainWindow(), tr("Import file"),
                    QString(""),
                    "XML files (*.xml)");

    if(fileName.isEmpty())
            return;

	this->openFile(fileName.toStdString());
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::saveAs()
{
    QString fileName = QFileDialog::getSaveFileName(this->getMonitoring()->getView()->getMainWindow(), tr("Export file"),
                    QString(""),
                    "XML files (*.xml)");

    if(fileName.isEmpty())
            return;

	this->saveAs(fileName.toStdString());
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openBrowser()
{
	DQMBrowserWidget *pBrowser = new DQMBrowserWidget(this->getMonitoring());

	pBrowser->setWindowTitle("DQM Browser");

	QString iconDir = QString(DQMViz_DIR) + "/icons";
	pBrowser->setWindowIcon(QIcon(iconDir + "/MON_BROWSER.png"));
	pBrowser->setAttribute(Qt::WA_DeleteOnClose, true);
	pBrowser->show();

	QObject::connect(this->getMonitoring()->getView()->getMainWindow(), SIGNAL(destroyed()), pBrowser, SLOT(close()));

//	m_browserList << pBrowser;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::aboutDQM4HEP()
{
	QString iconDir = QString(DQMViz_DIR) + "/icons";


	QStringList authorList;

	authorList << "R. Ete , IPNL"
			<< "A. Pingault, GHENT"
			<< "L. Mirabito, IPNL";

	QString text;

	text += "DQMHEP : Data Quality Monitoring for High Energy Physics\n\n";
	text += "Version : "+ QString(DQMViz_VERSION_STR) + "\n\n";

	text += "DQM4HEP is free software: you can redistribute it and/or modify ";
	text +=	"it under the terms of the GNU General Public License as published by";
	text +=	"the Free Software Foundation, either version 3 of the License, or";
	text +=	"(at your option) any later version.\n\n";

	text +=	"DQM4HEP is distributed in the hope that it will be useful,";
	text +=	"but WITHOUT ANY WARRANTY; without even the implied warranty of";
	text +=	"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the";
	text +=	"GNU General Public License for more details.\n\n";

	text +=	"You should have received a copy of the GNU General Public License";
	text +=	"along with DQM4HEP. If not, see <http://www.gnu.org/licenses/>.\n\n";

	text += "Authors :\n";
	text += "  * R. Ete , IPNL\n";
	text += "  * A. Pingault, Ghent University\n";
	text += "  * L. Mirabito, IPNL\n\n";

	text += "Please, send comments or report bug via the github interface ";
	text += "<https://github.com/rete/DQM4HEP/issues>";

	QMessageBox *pMessageBox = new QMessageBox(this->getMonitoring()->getView()->getMainWindow());
	pMessageBox->setWindowTitle("About DQM4HEP");
	pMessageBox->setIconPixmap(QPixmap(iconDir + "/MON_WIN.png").scaled(QSize(100, 100), Qt::KeepAspectRatioByExpanding));
	pMessageBox->setText(text);

	pMessageBox->exec();

	delete pMessageBox;
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openDoxygenDoc()
{
	QString indexHtml;
	indexHtml += DQMCore_DIR;
	indexHtml += "/doc/html/index.html";

	QDir dir;
	if(!dir.exists(indexHtml))
	{
		QMessageBox::information(this->getMonitoring()->getView()->getMainWindow(),
				"Not found",
				"DQM4HEP was not built with Doxygen documentation. Sorry !");
		return;
	}

	QDesktopServices::openUrl(QUrl::fromLocalFile(indexHtml));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openUserGuide()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openGithubPage()
{
	QDesktopServices::openUrl(QUrl("https://github.com/DQM4HEP"));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openIssuesPage()
{
	QDesktopServices::openUrl(QUrl("https://github.com/DQM4HEP/DQMViz/issues"));
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::clearViewAndModel()
{
	this->getMonitoring()->getView()->clear();
	this->getMonitoring()->getModel()->clear();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::sendMonitorElementRequests()
{
	DQMMonitorElementView *pMonitorElementView = this->getMonitoring()->getView()->getMonitorElementView();

	QStringList collectorNames = pMonitorElementView->getCollectorNames();
	int nRequestedElements = 0;

	for(int i=0 ; i<collectorNames.count() ; i++)
	{
		QList<QTreeWidgetItem*> checkedMonitorElements = pMonitorElementView->getCheckedMonitorElements(collectorNames.at(i).toStdString());

		DQMMonitorElementRequest request;

		for(int j=0 ; j<checkedMonitorElements.count() ; j++)
		{
			QTreeWidgetItem *pTreeItem = checkedMonitorElements.at(j);
			DQMMonitorElementNavigator *pNavigator = qobject_cast<DQMMonitorElementNavigator*>(pTreeItem->treeWidget());

			std::string moduleName = pNavigator->getModuleName(pTreeItem).toStdString();
			std::string fullPath = pNavigator->getFullPathName(pTreeItem).toStdString();
			std::string name = pTreeItem->text(0).toStdString();
			std::string fullPathName = (DQMPath(fullPath) + name).getPath();

			if(moduleName.empty() || fullPathName.empty())
				continue;

			nRequestedElements ++;
			request.m_requestList.push_back(DQMMonitorElementRequest::ModuleMonitorElementPair(moduleName, fullPathName));
		}

		this->sendMonitorElementRequest(collectorNames.at(i).toStdString(), request);
	}

	if(nRequestedElements > 0)
		this->log(MESSAGE, DQM4HEP::typeToString(nRequestedElements) + std::string(" request(s) sent to collectors"));
	else
		this->log(WARNING, "No request sent to collectors");
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::sendMonitorElementRequest(const std::string &collectorName, const DQMMonitorElementRequest &request)
{
	if(request.m_requestList.empty() || collectorName.empty())
		return;

	DQMGuiMonitorElementClient *pClient = this->getClient(collectorName);

	if(!pClient->getMonitorElementClient()->isConnectedToService())
		pClient->getMonitorElementClient()->connectToService();

	pClient->getMonitorElementClient()->sendMonitorElementPublicationRequest(request);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openMonitorElementInfo(DQMGuiMonitorElement *pGuiMonitorElement) const
{
	QDialog *pDialog = new QDialog();
	pDialog->setWindowTitle("Monitor element info (" + QString(pGuiMonitorElement->getMonitorElement()->getName().c_str()) + ")");

	QHBoxLayout *pLayout = new QHBoxLayout();
	pDialog->setLayout(pLayout);

	DQMMonitorElementInfoWidget *pMEInfoWidget = new DQMMonitorElementInfoWidget(pGuiMonitorElement);
	pMEInfoWidget->showTab(DQMMonitorElementInfoWidget::MONITOR_ELEMENT_INFO);

	pLayout->addWidget(pMEInfoWidget);

	pDialog->exec();
	pDialog->deleteLater();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openQualityTestResults(DQMGuiMonitorElement *pGuiMonitorElement) const
{
	QDialog *pDialog = new QDialog();
	pDialog->setWindowTitle("Monitor element info (" + QString(pGuiMonitorElement->getMonitorElement()->getName().c_str()) + ")");

	QHBoxLayout *pLayout = new QHBoxLayout();
	pDialog->setLayout(pLayout);

	DQMMonitorElementInfoWidget *pMEInfoWidget = new DQMMonitorElementInfoWidget(pGuiMonitorElement);
	pMEInfoWidget->showTab(DQMMonitorElementInfoWidget::QUALITY_TEST_RESULTS);

	pLayout->addWidget(pMEInfoWidget);

	pDialog->exec();
	pDialog->deleteLater();
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openInROOTWindow(DQMGuiMonitorElement *pMonitorElement) const
{
	TObject *pObject = pMonitorElement->getMonitorElement()->getObject();

	if(!pObject)
		return;

	pid_t pid = fork();

	// parent process
	if(pid != 0)
		return;

	// child process
	char templateFile[] = "/tmp/canvasTmpXXXXXX";
	int ret = mkstemp(templateFile);

	if(ret < 0)
		exit(-1);

	std::string tmpRootFileName = templateFile;
	tmpRootFileName += ".root";

	TFile *pTmpRootFile = TFile::Open(tmpRootFileName.c_str(), "RECREATE");

	if(!pTmpRootFile)
		exit(1);

	// re-add the pave stats
	TH1 *pHistogram = (TH1*)pObject;

	if(pHistogram)
		pHistogram->SetStats(1);

	pTmpRootFile->cd();
	pObject->Write("dqm4hep_open_root_canvas");
	delete pTmpRootFile;

	// full program name
	std::string fullPathProg = std::string(DQMCore_DIR) + "/bin/dqm4hep_open_root_canvas";
	char executivePath[1000];
	memset(executivePath, 0, 1000);

	memcpy(executivePath, fullPathProg.c_str(), fullPathProg.size());

	// fill arguments
	const unsigned int maxNArgs = 100;
	const unsigned int maxMArgs = 1000;

	char argv[maxNArgs][maxMArgs];
	char *pArgv[maxNArgs];

	for(unsigned int i=0 ; i<maxNArgs ; i++)
		for(unsigned int j=0 ; j<maxMArgs ; j++)
			argv[i][j] = char(NULL);

	pArgv[0] = executivePath;
	sprintf(argv[1], "%s", "-f");
	pArgv[1] = & argv[1][0];
	sprintf(argv[2], "%s", tmpRootFileName.c_str());
	pArgv[2] = & argv[2][0];
	pArgv[3] = NULL;

	// fill environment
	const unsigned int maxNEnv = 10;
	const unsigned int maxMEnv = 1000;

	char env[maxNEnv][maxMEnv];
	char *pEnv[maxNEnv];

	for(unsigned int i=0 ; i<maxNEnv ; i++)
		for(unsigned int j=0 ; j<maxMEnv ; j++)
			env[i][j] = char(NULL);

	sprintf(env[0], "%s", "DISPLAY=:0");
	pEnv[0] = & env[0][0];
	pEnv[1] = NULL;

	// start root panel from dqm4hep specific executable
	int execveRet = execve(executivePath, pArgv, pEnv);

	streamlog_out(ERROR) << "ERROR ! execve returned " << execveRet << " with errno set to " << errno << std::endl;
	streamlog_out(ERROR) << "Aborting" << std::endl;

	exit(1);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::openFile(const std::string &fileName)
{
	TiXmlDocument document(fileName);

	if(!document.LoadFile())
	{
		QMessageBox::warning(this->getMonitoring()->getView()->getMainWindow(),
				"XML Import",
				"Couldn't import selection from xml file :\n\n"
				"* Invalid XML file content");

		return;
	}

	TiXmlHandle documentHandle(&document);
	TiXmlElement *pRootElement = documentHandle.FirstChildElement().Element();

	if(!pRootElement)
	{
		QMessageBox::warning(this->getMonitoring()->getView()->getMainWindow(),
				"XML Import",
				"Couldn't import selection from xml file :\n\n"
				"* No root element found");

		return;
	}

	TiXmlHandle rootHandle(pRootElement);

	TiXmlElement *pMonitoringElement = rootHandle.FirstChild("monitoring").Element();

	if(!pMonitoringElement)
	{
		QMessageBox::warning(this->getMonitoring()->getView()->getMainWindow(),
				"XML Import",
				"Couldn't import selection from xml file :\n\n"
				"* No <monitoring> element found");

		return;
	}

	TiXmlHandle monitoringHandle(pMonitoringElement);

	this->clear();
	this->getMonitoring()->getModel()->clear();
	this->getMonitoring()->getView()->clear();

	TiXmlElement *pDimDnsNodeElement = monitoringHandle.FirstChild("dimDnsNode").Element();

	if(pDimDnsNodeElement)
	{
		std::string dimDnsNode;

		if(!pDimDnsNodeElement->QueryStringAttribute("value", &dimDnsNode))
			DimClient::setDnsNode(dimDnsNode.c_str());
	}

	TiXmlElement *pViewElement = monitoringHandle.FirstChild("view").Element();

	if(pViewElement)
		this->getMonitoring()->getView()->fromXml(pViewElement);

	TiXmlElement *pControllerElement = monitoringHandle.FirstChild("controller").Element();

	if(pControllerElement)
	{
		TiXmlHandle controllerHandle(pControllerElement);

        for (TiXmlElement *pCollectorElement = controllerHandle.FirstChild("collector").Element(); NULL != pCollectorElement;
        		pCollectorElement = pCollectorElement->NextSiblingElement("collector"))
        {
        	std::string collectorName;
            if(pCollectorElement->QueryStringAttribute("name", &collectorName))
                continue;

            this->getClient(collectorName);
        }
	}
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::saveAs(const std::string &fileName) const
{
	if(fileName.empty())
		return;

	TiXmlDocument document;

	TiXmlDeclaration *pDeclaration = new TiXmlDeclaration( "1.0", "", "" );
	document.LinkEndChild(pDeclaration);

	TiXmlElement *pRootElement = new TiXmlElement("dqm4hep");
	document.LinkEndChild(pRootElement);

	TiXmlElement *pMonitoringElement = new TiXmlElement("monitoring");
	pRootElement->LinkEndChild(pMonitoringElement);

	TiXmlElement *pDimDnsNodeElement = new TiXmlElement("dimDnsNode");
	pMonitoringElement->LinkEndChild(pDimDnsNodeElement);
	pDimDnsNodeElement->SetAttribute("value", DimClient::getDnsNode());

	TiXmlElement *pViewElement = this->getMonitoring()->getView()->toXml();

	if(pViewElement)
		pMonitoringElement->LinkEndChild(pViewElement);

	TiXmlElement *pControllerElement = new TiXmlElement("controller");

	for(DQMGuiMonitorElementClientMap::const_iterator iter = m_clientMap.begin(), endIter = m_clientMap.end() ;
			endIter != iter ; ++iter)
	{
		const std::string &collectorName = iter->first;

		TiXmlElement *pCollectorElement = new TiXmlElement("collector");
		pControllerElement->LinkEndChild(pCollectorElement);
		pCollectorElement->SetAttribute("value", collectorName);
	}

	pMonitoringElement->LinkEndChild(pControllerElement);

	document.SaveFile(fileName);
}

//-------------------------------------------------------------------------------------------------

void DQMMonitoringController::saveAs(DQMCanvas *pCanvas)
{
    QStringList formatList;
    QStringList extensionList;
    QString selectedFormat;

    formatList
            << "Postscript (*.ps)"
            << "Encapsulated Postscript (*.eps)"
            << "PDF (*.pdf)"
            << "GIF (*.gif)"
            << "JPG (*.jpg)"
            << "PNG (*.png)"
            << "ROOT Macro (*.C)"
            << "ROOT Files (*.root)";

    extensionList
            << ".ps"
            << ".eps"
            << ".pdf"
            << ".gif"
            << ".jpg"
            << ".png"
            << ".C"
            << ".root";

    QString fileName = QFileDialog::getSaveFileName(this->getMonitoring()->getView()->getMainWindow(),
    		"Save as",
            "",
            formatList.join(";;"),
            &selectedFormat);

    std::cout << "selectedFormat : " << selectedFormat.toStdString() << std::endl;

    if(fileName.isEmpty())
    	return;

    int lastIndexOf = fileName.lastIndexOf(extensionList.at(formatList.indexOf(selectedFormat)));
    QString baseFileName;
    QString extensionFileName;

    if(lastIndexOf < 0)
    {
        lastIndexOf = fileName.size() -1;
        baseFileName = fileName;
        int index = formatList.indexOf(selectedFormat);
        extensionFileName = extensionList.at(index);
    }
    else
    {
        baseFileName = fileName.left(lastIndexOf);
        extensionFileName = fileName.right(fileName.size() - lastIndexOf);
    }

    std::string realFileName = (baseFileName + extensionFileName).toStdString();

    // save the canvas
    pCanvas->getRootWidget()->GetCanvas()->SaveAs(realFileName.c_str());
}

void DQMMonitoringController::saveAs(DQMCanvasArea *pCanvasArea)
{
	QList<QMdiSubWindow*> subWindows = pCanvasArea->subWindowList();

	if(subWindows.isEmpty())
		return;

    QStringList formatList;
    QStringList extensionList;
    QString selectedFormat;

    formatList
//            << "Postscript (*.ps)"
//            << "Encapsulated Postscript (*.eps)"
//            << "PDF (*.pdf)"
//            << "GIF (*.gif)"
//            << "JPG (*.jpg)"
//            << "PNG (*.png)"
//            << "ROOT Macro (*.C)"
            << "ROOT Files (*.root)";

    extensionList
//            << ".ps"
//            << ".eps"
//            << ".pdf"
//            << ".gif"
//            << ".jpg"
//            << ".png"
//            << ".C"
            << ".root";

    QString fileName = QFileDialog::getSaveFileName(this->getMonitoring()->getView()->getMainWindow(),
    		"Save as",
            "",
            formatList.join(";;"),
            &selectedFormat);

    if(fileName.isEmpty())
    	return;

    int lastIndexOf = fileName.lastIndexOf(extensionList.at(formatList.indexOf(selectedFormat)));
    QString baseFileName;
    QString extensionFileName;

    if(lastIndexOf < 0)
    {
        lastIndexOf = fileName.size() -1;
        baseFileName = fileName;
        int index = formatList.indexOf(selectedFormat);
        extensionFileName = extensionList.at(index);
    }
    else
    {
        baseFileName = fileName.left(lastIndexOf);
        extensionFileName = fileName.right(fileName.size() - lastIndexOf);
    }

    std::string realFileName = (baseFileName + extensionFileName).toStdString();

    TFile *pFile = TFile::Open(realFileName.c_str(), "RECREATE");

    if(NULL == pFile)
    	return;

    for(int i=0 ; i<subWindows.count() ; i++)
    {
    	DQMCanvas *pCanvas = qobject_cast<DQMCanvas*>(subWindows.at(i));

    	if(!pCanvas)
    		continue;

    	TCanvas *pSaveCanvas = pCanvas->getRootWidget()->GetCanvas();
    	std::string objectName = pCanvas->getCurrentMonitorElement()->getMonitorElement()->getName();
    	pFile->WriteTObject(pSaveCanvas, objectName.c_str());
    }

    pFile->Close();
    delete pFile;
}


void DQMMonitoringController::quit()
{
	this->clear();
	this->getMonitoring()->getModel()->clear();
	this->getMonitoring()->getView()->clear();
	qApp->closeAllWindows();
	qApp->quit();
}


void DQMMonitoringController::handleMonitorElementPublicationReception(const DQMMonitorElementPublication &publication)
{
	DQMGuiMonitorElementClient *pClient = qobject_cast<DQMGuiMonitorElementClient*>(sender());

	for(DQMMonitorElementPublication::PublicationMap::const_iterator iter = publication.m_publication.begin(), endIter = publication.m_publication.end() ;
			endIter != iter ; ++iter)
	{
		std::string moduleName = iter->first;

		for(int i=0 ; i<iter->second.size() ; i++)
			this->getMonitoring()->getModel()->updateMonitorElement(iter->second.at(i));
	}
}


} 

